
<usermanual>
    For background see:
    Press et al., Numerical Recipes in C: The Art of Scientific Computing, 2nd Ed. (1992), 
    Chapter 3.3 Cubic Spline Interpolation, pg. 113 - 116.
</usermanual>

// input: parameter space to construct the splines over
// x values must be in ascending order, x values must be unique
<list x>
// items = (-10, -6.5, -3.5, -1.5, -0.2, 0, 1, 3.5, 5, 6.5, 10, 15, 20, 23, 30) // x values of 1st example input space 
// items = (-10, -6.5, -3.5, 0, 3.5, 6.5, 10) // x values of 2nd example input space 
// items = (-1.5, -0.2, 1.0, 5.0, 10.0, 15.0, 20.0) // x values of 3rd example input space 
</list>
<list y>
// items = (0, 0.1, -0.1, -1.2, 0, -0.4, 0.5, -0.1, 0.1, 0, 2, 1, 5, 3, -1) // y values of 1st example input space 
// items = (0, 0.1, -0.1, 1, -0.1, 0.1, 0) // y values of 2nd example input space 
// items = (-1.2, 0.0, 0.5, 1.0, 1.2, 2.0, 1.0) // y values of 3rd example input space 
</list>

<include>
/ file = "values-5888.txt"
</include>

<include>
/ file = "RTs-5888.txt"
</include>

// temp storage
<list u>
</list>
// output y of 2nd derivative
<list y2> 
</list>

<expressions>
// constructs the cubic splines over the input parameter space
/ createSpline = {
    list.y2.reset();
    list.u.reset();
    var n = list.x.itemcount;
    // setting up the vectors with n items
    var i = 1;
    while (i <= n) {
        list.y2.appenditem(null);
        list.u.appenditem(null);
        i += 1;
    };
    i = 1;
    // natural boundary condition on leftmost point
    list.y2.setitem(0.0, i);
    list.u.setitem(0.0, i);
    // decomposition
    i = 2;
    while (i <= n-1) {
        //sig=(x[i]-x[i-1])/(x[i+1]-x[i-1]);
        var sig = (list.x.item(i) - list.x.item(i-1)) / (list.x.item(i+1) - list.x.item(i-1));
        //p=sig*y2[i-1]+2.0
        var p = sig * list.y2.item(i-1) + 2.0;
        //y2[i]=(sig-1.0)/p;
        var y2i = (sig - 1.0) / p;
        list.y2.setitem(y2i, i);
        //u[i]=(y[i+1]-y[i])/(x[i+1]-x[i]) - (y[i]-y[i-1])/(x[i]-x[i-1]);
        var ui = (list.y.item(i+1) - list.y.item(i)) / (list.x.item(i+1) - list.x.item(i)) - (list.y.item(i) - list.y.item(i-1)) / (list.x.item(i) - list.x.item(i-1));
        list.u.setitem(ui, i);
        //u[i]=(6.0*u[i]/(x[i+1]-x[i-1])-sig*u[i-1])/p;
        ui = (6.0 * list.u.item(i) / (list.x.item(i+1) - list.x.item(i-1)) - sig * list.u.item(i-1)) / p;
        list.u.setitem(ui, i);
        i += 1;
    };
    // natural boundary condition on rightmost point
    var qn = 0.0;
    var un = 0.0;
    //y2[n]=(un-qn*u[n-1])/(qn*y2[n-1]+1.0);
    var y2n = (un - qn * list.u.item(n-1)) / (qn * list.y2.item(n-1) + 1.0);
    list.y2.setitem(y2n, n);
    // backsubstitution
    var k = n-1;
    while (k >= 1) {
        //y2[k]=y2[k]*y2[k+1]+u[k];
        var y2k = list.y2.item(k) * list.y2.item(k+1) + list.u.item(k);
        list.y2.setitem(y2k, k);
        k -= 1;
    };
};

// sets up a test vector of x values in the range x1 to xn
/ createTestVector = {
	values.master_idx = 0;
	while (values.master_idx < 360){
		values.master_idx += 1;
		list.RT.nextindex;
		list.values.nextindex;
		if (values.master_idx == 150 -15){
			list.y.appenditem(list.values.currentvalue);
			list.x.appenditem(list.RT.currentvalue);
		} else if (values.master_idx == 150){	
			list.y.appenditem(50);
			list.x.appenditem(list.RT.currentvalue);
		} else if (values.master_idx == 150 + 15) {
			list.y.appenditem(list.values.currentvalue);
			list.x.appenditem(list.RT.currentvalue);
		} else {
		}
	};
	
	
    var x1 = list.x.item(1);
    var xn = list.x.item(list.x.itemcount);
    var x =  x1;
    // set up a test vector of x values in range x1 to xn
    while (x <= xn) {
        list.x_test.appenditem(x);
        list.y_test.appenditem(null);
        x += 1; // decrease for denser sampling (more points), increase for sparser sampling (fewer points)
    };
};

// given an x value, finds the insertion point and returns interpolated y value
/ interpolateSpline = {
    // bisect
    var x = values.x;
    var n = list.x.itemcount;
    var klo = 1;
    var khi = n;
    while (khi - klo > 1) {
        var k = floor((khi + klo) / 2); // same as right bit shift
        if (list.x.item(k) > x) {
            khi = k;
        } else {
            klo = k;
        };
    };
    var h = list.x.item(khi) - list.x.item(klo);
    //a=(xa[khi]-x)/h;
    var a = (list.x.item(khi) - x) / h;
    //b=(x-xa[klo])/h;
    var b = (x - list.x.item(klo)) / h;
    // calculate interpolated y
    // y=a*ya[klo]+b*ya[khi]+((a*a*a-a)*y2a[klo]+(b*b*b-b)*y2a[khi])*(h*h)/6.0
    var y = a * list.y.item(klo) + b * list.y.item(khi) + ((a*a*a - a) * list.y2.item(klo) + (b*b*b - b) * list.y2.item(khi)) * (h*h) / 6.0;
    return y;
};
</expressions>

// test vectors holding interpolated x / y values
<list x_test> 
/ selectionmode = sequence
</list>
<list y_test>
</list>

<values>
/ x = null
/ y = null
/ master_idx = null
</values>

<block exampleBlock>
/ onblockbegin = [
	expressions.createTestVector; // call the test vector generation routine
    expressions.createSpline; // call the spline construction routine 
]
/ trials = [1=interpolateSpline]
</block>

// pass x values to the interpolation routine, get interpolated y values
<trial interpolateSpline>
/ ontrialbegin = [
    values.x = list.x_test.nextvalue; // get our x value
    values.y = expressions.interpolateSpline; // get our interpolated y value
    list.y_test.setitem(values.y, list.x_test.currentindex); // add interpolated y to the test vector
]
/ trialduration = 0
/ branch = [
    if (list.x_test.selectedcount < list.x_test.itemcount) {    // run as often as we have x values in our test vector
        return trial.interpolateSpline;                         // this is just for ease of data output and plotting, it's not a problem to 
    };                                                            // wrap everything in a single while() loop
]
</trial>

<data>
/ columns = (trialnum values.x values.y) // write out x and y one value pair per row for easy plotting
/ separatefiles = true
</data>
